// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package lightning

import (
	"context"

	"github.com/BoltzExchange/boltz-client/v2/internal/lightning"
	"github.com/BoltzExchange/boltz-client/v2/internal/onchain"
	mock "github.com/stretchr/testify/mock"
)

// NewMockLightningNode creates a new instance of MockLightningNode. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockLightningNode(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockLightningNode {
	mock := &MockLightningNode{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockLightningNode is an autogenerated mock type for the LightningNode type
type MockLightningNode struct {
	mock.Mock
}

type MockLightningNode_Expecter struct {
	mock *mock.Mock
}

func (_m *MockLightningNode) EXPECT() *MockLightningNode_Expecter {
	return &MockLightningNode_Expecter{mock: &_m.Mock}
}

// BumpTransactionFee provides a mock function for the type MockLightningNode
func (_mock *MockLightningNode) BumpTransactionFee(txId string, satPerVbyte float64) (string, error) {
	ret := _mock.Called(txId, satPerVbyte)

	if len(ret) == 0 {
		panic("no return value specified for BumpTransactionFee")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string, float64) (string, error)); ok {
		return returnFunc(txId, satPerVbyte)
	}
	if returnFunc, ok := ret.Get(0).(func(string, float64) string); ok {
		r0 = returnFunc(txId, satPerVbyte)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(string, float64) error); ok {
		r1 = returnFunc(txId, satPerVbyte)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLightningNode_BumpTransactionFee_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BumpTransactionFee'
type MockLightningNode_BumpTransactionFee_Call struct {
	*mock.Call
}

// BumpTransactionFee is a helper method to define mock.On call
//   - txId string
//   - satPerVbyte float64
func (_e *MockLightningNode_Expecter) BumpTransactionFee(txId interface{}, satPerVbyte interface{}) *MockLightningNode_BumpTransactionFee_Call {
	return &MockLightningNode_BumpTransactionFee_Call{Call: _e.mock.On("BumpTransactionFee", txId, satPerVbyte)}
}

func (_c *MockLightningNode_BumpTransactionFee_Call) Run(run func(txId string, satPerVbyte float64)) *MockLightningNode_BumpTransactionFee_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 float64
		if args[1] != nil {
			arg1 = args[1].(float64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockLightningNode_BumpTransactionFee_Call) Return(s string, err error) *MockLightningNode_BumpTransactionFee_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *MockLightningNode_BumpTransactionFee_Call) RunAndReturn(run func(txId string, satPerVbyte float64) (string, error)) *MockLightningNode_BumpTransactionFee_Call {
	_c.Call.Return(run)
	return _c
}

// CheckInvoicePaid provides a mock function for the type MockLightningNode
func (_mock *MockLightningNode) CheckInvoicePaid(paymentHash []byte) (bool, error) {
	ret := _mock.Called(paymentHash)

	if len(ret) == 0 {
		panic("no return value specified for CheckInvoicePaid")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte) (bool, error)); ok {
		return returnFunc(paymentHash)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte) bool); ok {
		r0 = returnFunc(paymentHash)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = returnFunc(paymentHash)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLightningNode_CheckInvoicePaid_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckInvoicePaid'
type MockLightningNode_CheckInvoicePaid_Call struct {
	*mock.Call
}

// CheckInvoicePaid is a helper method to define mock.On call
//   - paymentHash []byte
func (_e *MockLightningNode_Expecter) CheckInvoicePaid(paymentHash interface{}) *MockLightningNode_CheckInvoicePaid_Call {
	return &MockLightningNode_CheckInvoicePaid_Call{Call: _e.mock.On("CheckInvoicePaid", paymentHash)}
}

func (_c *MockLightningNode_CheckInvoicePaid_Call) Run(run func(paymentHash []byte)) *MockLightningNode_CheckInvoicePaid_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockLightningNode_CheckInvoicePaid_Call) Return(b bool, err error) *MockLightningNode_CheckInvoicePaid_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockLightningNode_CheckInvoicePaid_Call) RunAndReturn(run func(paymentHash []byte) (bool, error)) *MockLightningNode_CheckInvoicePaid_Call {
	_c.Call.Return(run)
	return _c
}

// Connect provides a mock function for the type MockLightningNode
func (_mock *MockLightningNode) Connect() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Connect")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockLightningNode_Connect_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Connect'
type MockLightningNode_Connect_Call struct {
	*mock.Call
}

// Connect is a helper method to define mock.On call
func (_e *MockLightningNode_Expecter) Connect() *MockLightningNode_Connect_Call {
	return &MockLightningNode_Connect_Call{Call: _e.mock.On("Connect")}
}

func (_c *MockLightningNode_Connect_Call) Run(run func()) *MockLightningNode_Connect_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockLightningNode_Connect_Call) Return(err error) *MockLightningNode_Connect_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockLightningNode_Connect_Call) RunAndReturn(run func() error) *MockLightningNode_Connect_Call {
	_c.Call.Return(run)
	return _c
}

// CreateInvoice provides a mock function for the type MockLightningNode
func (_mock *MockLightningNode) CreateInvoice(value uint64, preimage []byte, expiry int64, memo string) (*lightning.AddInvoiceResponse, error) {
	ret := _mock.Called(value, preimage, expiry, memo)

	if len(ret) == 0 {
		panic("no return value specified for CreateInvoice")
	}

	var r0 *lightning.AddInvoiceResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint64, []byte, int64, string) (*lightning.AddInvoiceResponse, error)); ok {
		return returnFunc(value, preimage, expiry, memo)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64, []byte, int64, string) *lightning.AddInvoiceResponse); ok {
		r0 = returnFunc(value, preimage, expiry, memo)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lightning.AddInvoiceResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(uint64, []byte, int64, string) error); ok {
		r1 = returnFunc(value, preimage, expiry, memo)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLightningNode_CreateInvoice_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateInvoice'
type MockLightningNode_CreateInvoice_Call struct {
	*mock.Call
}

// CreateInvoice is a helper method to define mock.On call
//   - value uint64
//   - preimage []byte
//   - expiry int64
//   - memo string
func (_e *MockLightningNode_Expecter) CreateInvoice(value interface{}, preimage interface{}, expiry interface{}, memo interface{}) *MockLightningNode_CreateInvoice_Call {
	return &MockLightningNode_CreateInvoice_Call{Call: _e.mock.On("CreateInvoice", value, preimage, expiry, memo)}
}

func (_c *MockLightningNode_CreateInvoice_Call) Run(run func(value uint64, preimage []byte, expiry int64, memo string)) *MockLightningNode_CreateInvoice_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		var arg1 []byte
		if args[1] != nil {
			arg1 = args[1].([]byte)
		}
		var arg2 int64
		if args[2] != nil {
			arg2 = args[2].(int64)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockLightningNode_CreateInvoice_Call) Return(addInvoiceResponse *lightning.AddInvoiceResponse, err error) *MockLightningNode_CreateInvoice_Call {
	_c.Call.Return(addInvoiceResponse, err)
	return _c
}

func (_c *MockLightningNode_CreateInvoice_Call) RunAndReturn(run func(value uint64, preimage []byte, expiry int64, memo string) (*lightning.AddInvoiceResponse, error)) *MockLightningNode_CreateInvoice_Call {
	_c.Call.Return(run)
	return _c
}

// Disconnect provides a mock function for the type MockLightningNode
func (_mock *MockLightningNode) Disconnect() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Disconnect")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockLightningNode_Disconnect_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Disconnect'
type MockLightningNode_Disconnect_Call struct {
	*mock.Call
}

// Disconnect is a helper method to define mock.On call
func (_e *MockLightningNode_Expecter) Disconnect() *MockLightningNode_Disconnect_Call {
	return &MockLightningNode_Disconnect_Call{Call: _e.mock.On("Disconnect")}
}

func (_c *MockLightningNode_Disconnect_Call) Run(run func()) *MockLightningNode_Disconnect_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockLightningNode_Disconnect_Call) Return(err error) *MockLightningNode_Disconnect_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockLightningNode_Disconnect_Call) RunAndReturn(run func() error) *MockLightningNode_Disconnect_Call {
	_c.Call.Return(run)
	return _c
}

// GetBalance provides a mock function for the type MockLightningNode
func (_mock *MockLightningNode) GetBalance() (*onchain.Balance, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetBalance")
	}

	var r0 *onchain.Balance
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (*onchain.Balance, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() *onchain.Balance); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*onchain.Balance)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLightningNode_GetBalance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBalance'
type MockLightningNode_GetBalance_Call struct {
	*mock.Call
}

// GetBalance is a helper method to define mock.On call
func (_e *MockLightningNode_Expecter) GetBalance() *MockLightningNode_GetBalance_Call {
	return &MockLightningNode_GetBalance_Call{Call: _e.mock.On("GetBalance")}
}

func (_c *MockLightningNode_GetBalance_Call) Run(run func()) *MockLightningNode_GetBalance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockLightningNode_GetBalance_Call) Return(balance *onchain.Balance, err error) *MockLightningNode_GetBalance_Call {
	_c.Call.Return(balance, err)
	return _c
}

func (_c *MockLightningNode_GetBalance_Call) RunAndReturn(run func() (*onchain.Balance, error)) *MockLightningNode_GetBalance_Call {
	_c.Call.Return(run)
	return _c
}

// GetInfo provides a mock function for the type MockLightningNode
func (_mock *MockLightningNode) GetInfo() (*lightning.LightningInfo, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetInfo")
	}

	var r0 *lightning.LightningInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (*lightning.LightningInfo, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() *lightning.LightningInfo); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lightning.LightningInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLightningNode_GetInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetInfo'
type MockLightningNode_GetInfo_Call struct {
	*mock.Call
}

// GetInfo is a helper method to define mock.On call
func (_e *MockLightningNode_Expecter) GetInfo() *MockLightningNode_GetInfo_Call {
	return &MockLightningNode_GetInfo_Call{Call: _e.mock.On("GetInfo")}
}

func (_c *MockLightningNode_GetInfo_Call) Run(run func()) *MockLightningNode_GetInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockLightningNode_GetInfo_Call) Return(lightningInfo *lightning.LightningInfo, err error) *MockLightningNode_GetInfo_Call {
	_c.Call.Return(lightningInfo, err)
	return _c
}

func (_c *MockLightningNode_GetInfo_Call) RunAndReturn(run func() (*lightning.LightningInfo, error)) *MockLightningNode_GetInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetTransactions provides a mock function for the type MockLightningNode
func (_mock *MockLightningNode) GetTransactions(limit uint64, offset uint64) ([]*onchain.WalletTransaction, error) {
	ret := _mock.Called(limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for GetTransactions")
	}

	var r0 []*onchain.WalletTransaction
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint64, uint64) ([]*onchain.WalletTransaction, error)); ok {
		return returnFunc(limit, offset)
	}
	if returnFunc, ok := ret.Get(0).(func(uint64, uint64) []*onchain.WalletTransaction); ok {
		r0 = returnFunc(limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*onchain.WalletTransaction)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(uint64, uint64) error); ok {
		r1 = returnFunc(limit, offset)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLightningNode_GetTransactions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTransactions'
type MockLightningNode_GetTransactions_Call struct {
	*mock.Call
}

// GetTransactions is a helper method to define mock.On call
//   - limit uint64
//   - offset uint64
func (_e *MockLightningNode_Expecter) GetTransactions(limit interface{}, offset interface{}) *MockLightningNode_GetTransactions_Call {
	return &MockLightningNode_GetTransactions_Call{Call: _e.mock.On("GetTransactions", limit, offset)}
}

func (_c *MockLightningNode_GetTransactions_Call) Run(run func(limit uint64, offset uint64)) *MockLightningNode_GetTransactions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint64
		if args[0] != nil {
			arg0 = args[0].(uint64)
		}
		var arg1 uint64
		if args[1] != nil {
			arg1 = args[1].(uint64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockLightningNode_GetTransactions_Call) Return(walletTransactions []*onchain.WalletTransaction, err error) *MockLightningNode_GetTransactions_Call {
	_c.Call.Return(walletTransactions, err)
	return _c
}

func (_c *MockLightningNode_GetTransactions_Call) RunAndReturn(run func(limit uint64, offset uint64) ([]*onchain.WalletTransaction, error)) *MockLightningNode_GetTransactions_Call {
	_c.Call.Return(run)
	return _c
}

// GetWalletInfo provides a mock function for the type MockLightningNode
func (_mock *MockLightningNode) GetWalletInfo() onchain.WalletInfo {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetWalletInfo")
	}

	var r0 onchain.WalletInfo
	if returnFunc, ok := ret.Get(0).(func() onchain.WalletInfo); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(onchain.WalletInfo)
	}
	return r0
}

// MockLightningNode_GetWalletInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWalletInfo'
type MockLightningNode_GetWalletInfo_Call struct {
	*mock.Call
}

// GetWalletInfo is a helper method to define mock.On call
func (_e *MockLightningNode_Expecter) GetWalletInfo() *MockLightningNode_GetWalletInfo_Call {
	return &MockLightningNode_GetWalletInfo_Call{Call: _e.mock.On("GetWalletInfo")}
}

func (_c *MockLightningNode_GetWalletInfo_Call) Run(run func()) *MockLightningNode_GetWalletInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockLightningNode_GetWalletInfo_Call) Return(walletInfo onchain.WalletInfo) *MockLightningNode_GetWalletInfo_Call {
	_c.Call.Return(walletInfo)
	return _c
}

func (_c *MockLightningNode_GetWalletInfo_Call) RunAndReturn(run func() onchain.WalletInfo) *MockLightningNode_GetWalletInfo_Call {
	_c.Call.Return(run)
	return _c
}

// ListChannels provides a mock function for the type MockLightningNode
func (_mock *MockLightningNode) ListChannels() ([]*lightning.LightningChannel, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for ListChannels")
	}

	var r0 []*lightning.LightningChannel
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() ([]*lightning.LightningChannel, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() []*lightning.LightningChannel); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*lightning.LightningChannel)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLightningNode_ListChannels_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListChannels'
type MockLightningNode_ListChannels_Call struct {
	*mock.Call
}

// ListChannels is a helper method to define mock.On call
func (_e *MockLightningNode_Expecter) ListChannels() *MockLightningNode_ListChannels_Call {
	return &MockLightningNode_ListChannels_Call{Call: _e.mock.On("ListChannels")}
}

func (_c *MockLightningNode_ListChannels_Call) Run(run func()) *MockLightningNode_ListChannels_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockLightningNode_ListChannels_Call) Return(lightningChannels []*lightning.LightningChannel, err error) *MockLightningNode_ListChannels_Call {
	_c.Call.Return(lightningChannels, err)
	return _c
}

func (_c *MockLightningNode_ListChannels_Call) RunAndReturn(run func() ([]*lightning.LightningChannel, error)) *MockLightningNode_ListChannels_Call {
	_c.Call.Return(run)
	return _c
}

// Name provides a mock function for the type MockLightningNode
func (_mock *MockLightningNode) Name() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Name")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// MockLightningNode_Name_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Name'
type MockLightningNode_Name_Call struct {
	*mock.Call
}

// Name is a helper method to define mock.On call
func (_e *MockLightningNode_Expecter) Name() *MockLightningNode_Name_Call {
	return &MockLightningNode_Name_Call{Call: _e.mock.On("Name")}
}

func (_c *MockLightningNode_Name_Call) Run(run func()) *MockLightningNode_Name_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockLightningNode_Name_Call) Return(s string) *MockLightningNode_Name_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *MockLightningNode_Name_Call) RunAndReturn(run func() string) *MockLightningNode_Name_Call {
	_c.Call.Return(run)
	return _c
}

// NewAddress provides a mock function for the type MockLightningNode
func (_mock *MockLightningNode) NewAddress() (string, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for NewAddress")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (string, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLightningNode_NewAddress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewAddress'
type MockLightningNode_NewAddress_Call struct {
	*mock.Call
}

// NewAddress is a helper method to define mock.On call
func (_e *MockLightningNode_Expecter) NewAddress() *MockLightningNode_NewAddress_Call {
	return &MockLightningNode_NewAddress_Call{Call: _e.mock.On("NewAddress")}
}

func (_c *MockLightningNode_NewAddress_Call) Run(run func()) *MockLightningNode_NewAddress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockLightningNode_NewAddress_Call) Return(s string, err error) *MockLightningNode_NewAddress_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *MockLightningNode_NewAddress_Call) RunAndReturn(run func() (string, error)) *MockLightningNode_NewAddress_Call {
	_c.Call.Return(run)
	return _c
}

// PayInvoice provides a mock function for the type MockLightningNode
func (_mock *MockLightningNode) PayInvoice(ctx context.Context, invoice string, feeLimit uint, timeoutSeconds uint, channelIds []lightning.ChanId) (*lightning.PayInvoiceResponse, error) {
	ret := _mock.Called(ctx, invoice, feeLimit, timeoutSeconds, channelIds)

	if len(ret) == 0 {
		panic("no return value specified for PayInvoice")
	}

	var r0 *lightning.PayInvoiceResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, uint, uint, []lightning.ChanId) (*lightning.PayInvoiceResponse, error)); ok {
		return returnFunc(ctx, invoice, feeLimit, timeoutSeconds, channelIds)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, uint, uint, []lightning.ChanId) *lightning.PayInvoiceResponse); ok {
		r0 = returnFunc(ctx, invoice, feeLimit, timeoutSeconds, channelIds)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lightning.PayInvoiceResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, uint, uint, []lightning.ChanId) error); ok {
		r1 = returnFunc(ctx, invoice, feeLimit, timeoutSeconds, channelIds)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLightningNode_PayInvoice_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PayInvoice'
type MockLightningNode_PayInvoice_Call struct {
	*mock.Call
}

// PayInvoice is a helper method to define mock.On call
//   - ctx context.Context
//   - invoice string
//   - feeLimit uint
//   - timeoutSeconds uint
//   - channelIds []lightning.ChanId
func (_e *MockLightningNode_Expecter) PayInvoice(ctx interface{}, invoice interface{}, feeLimit interface{}, timeoutSeconds interface{}, channelIds interface{}) *MockLightningNode_PayInvoice_Call {
	return &MockLightningNode_PayInvoice_Call{Call: _e.mock.On("PayInvoice", ctx, invoice, feeLimit, timeoutSeconds, channelIds)}
}

func (_c *MockLightningNode_PayInvoice_Call) Run(run func(ctx context.Context, invoice string, feeLimit uint, timeoutSeconds uint, channelIds []lightning.ChanId)) *MockLightningNode_PayInvoice_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 uint
		if args[2] != nil {
			arg2 = args[2].(uint)
		}
		var arg3 uint
		if args[3] != nil {
			arg3 = args[3].(uint)
		}
		var arg4 []lightning.ChanId
		if args[4] != nil {
			arg4 = args[4].([]lightning.ChanId)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *MockLightningNode_PayInvoice_Call) Return(payInvoiceResponse *lightning.PayInvoiceResponse, err error) *MockLightningNode_PayInvoice_Call {
	_c.Call.Return(payInvoiceResponse, err)
	return _c
}

func (_c *MockLightningNode_PayInvoice_Call) RunAndReturn(run func(ctx context.Context, invoice string, feeLimit uint, timeoutSeconds uint, channelIds []lightning.ChanId) (*lightning.PayInvoiceResponse, error)) *MockLightningNode_PayInvoice_Call {
	_c.Call.Return(run)
	return _c
}

// PaymentStatus provides a mock function for the type MockLightningNode
func (_mock *MockLightningNode) PaymentStatus(paymentHash []byte) (*lightning.PaymentStatus, error) {
	ret := _mock.Called(paymentHash)

	if len(ret) == 0 {
		panic("no return value specified for PaymentStatus")
	}

	var r0 *lightning.PaymentStatus
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte) (*lightning.PaymentStatus, error)); ok {
		return returnFunc(paymentHash)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte) *lightning.PaymentStatus); ok {
		r0 = returnFunc(paymentHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lightning.PaymentStatus)
		}
	}
	if returnFunc, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = returnFunc(paymentHash)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLightningNode_PaymentStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PaymentStatus'
type MockLightningNode_PaymentStatus_Call struct {
	*mock.Call
}

// PaymentStatus is a helper method to define mock.On call
//   - paymentHash []byte
func (_e *MockLightningNode_Expecter) PaymentStatus(paymentHash interface{}) *MockLightningNode_PaymentStatus_Call {
	return &MockLightningNode_PaymentStatus_Call{Call: _e.mock.On("PaymentStatus", paymentHash)}
}

func (_c *MockLightningNode_PaymentStatus_Call) Run(run func(paymentHash []byte)) *MockLightningNode_PaymentStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockLightningNode_PaymentStatus_Call) Return(paymentStatus *lightning.PaymentStatus, err error) *MockLightningNode_PaymentStatus_Call {
	_c.Call.Return(paymentStatus, err)
	return _c
}

func (_c *MockLightningNode_PaymentStatus_Call) RunAndReturn(run func(paymentHash []byte) (*lightning.PaymentStatus, error)) *MockLightningNode_PaymentStatus_Call {
	_c.Call.Return(run)
	return _c
}

// Ready provides a mock function for the type MockLightningNode
func (_mock *MockLightningNode) Ready() bool {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Ready")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func() bool); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// MockLightningNode_Ready_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Ready'
type MockLightningNode_Ready_Call struct {
	*mock.Call
}

// Ready is a helper method to define mock.On call
func (_e *MockLightningNode_Expecter) Ready() *MockLightningNode_Ready_Call {
	return &MockLightningNode_Ready_Call{Call: _e.mock.On("Ready")}
}

func (_c *MockLightningNode_Ready_Call) Run(run func()) *MockLightningNode_Ready_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockLightningNode_Ready_Call) Return(b bool) *MockLightningNode_Ready_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *MockLightningNode_Ready_Call) RunAndReturn(run func() bool) *MockLightningNode_Ready_Call {
	_c.Call.Return(run)
	return _c
}

// SendToAddress provides a mock function for the type MockLightningNode
func (_mock *MockLightningNode) SendToAddress(address string, amount uint64, satPerVbyte float64, sendAll bool) (string, error) {
	ret := _mock.Called(address, amount, satPerVbyte, sendAll)

	if len(ret) == 0 {
		panic("no return value specified for SendToAddress")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string, uint64, float64, bool) (string, error)); ok {
		return returnFunc(address, amount, satPerVbyte, sendAll)
	}
	if returnFunc, ok := ret.Get(0).(func(string, uint64, float64, bool) string); ok {
		r0 = returnFunc(address, amount, satPerVbyte, sendAll)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(string, uint64, float64, bool) error); ok {
		r1 = returnFunc(address, amount, satPerVbyte, sendAll)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLightningNode_SendToAddress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendToAddress'
type MockLightningNode_SendToAddress_Call struct {
	*mock.Call
}

// SendToAddress is a helper method to define mock.On call
//   - address string
//   - amount uint64
//   - satPerVbyte float64
//   - sendAll bool
func (_e *MockLightningNode_Expecter) SendToAddress(address interface{}, amount interface{}, satPerVbyte interface{}, sendAll interface{}) *MockLightningNode_SendToAddress_Call {
	return &MockLightningNode_SendToAddress_Call{Call: _e.mock.On("SendToAddress", address, amount, satPerVbyte, sendAll)}
}

func (_c *MockLightningNode_SendToAddress_Call) Run(run func(address string, amount uint64, satPerVbyte float64, sendAll bool)) *MockLightningNode_SendToAddress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 uint64
		if args[1] != nil {
			arg1 = args[1].(uint64)
		}
		var arg2 float64
		if args[2] != nil {
			arg2 = args[2].(float64)
		}
		var arg3 bool
		if args[3] != nil {
			arg3 = args[3].(bool)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockLightningNode_SendToAddress_Call) Return(s string, err error) *MockLightningNode_SendToAddress_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *MockLightningNode_SendToAddress_Call) RunAndReturn(run func(address string, amount uint64, satPerVbyte float64, sendAll bool) (string, error)) *MockLightningNode_SendToAddress_Call {
	_c.Call.Return(run)
	return _c
}

// SetupWallet provides a mock function for the type MockLightningNode
func (_mock *MockLightningNode) SetupWallet(info onchain.WalletInfo) {
	_mock.Called(info)
	return
}

// MockLightningNode_SetupWallet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetupWallet'
type MockLightningNode_SetupWallet_Call struct {
	*mock.Call
}

// SetupWallet is a helper method to define mock.On call
//   - info onchain.WalletInfo
func (_e *MockLightningNode_Expecter) SetupWallet(info interface{}) *MockLightningNode_SetupWallet_Call {
	return &MockLightningNode_SetupWallet_Call{Call: _e.mock.On("SetupWallet", info)}
}

func (_c *MockLightningNode_SetupWallet_Call) Run(run func(info onchain.WalletInfo)) *MockLightningNode_SetupWallet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 onchain.WalletInfo
		if args[0] != nil {
			arg0 = args[0].(onchain.WalletInfo)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockLightningNode_SetupWallet_Call) Return() *MockLightningNode_SetupWallet_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockLightningNode_SetupWallet_Call) RunAndReturn(run func(info onchain.WalletInfo)) *MockLightningNode_SetupWallet_Call {
	_c.Run(run)
	return _c
}
