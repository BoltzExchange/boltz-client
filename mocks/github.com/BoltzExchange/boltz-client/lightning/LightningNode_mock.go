// Code generated by mockery v2.42.2. DO NOT EDIT.

package lightning

import (
	context "context"

	lightning "github.com/BoltzExchange/boltz-client/lightning"
	mock "github.com/stretchr/testify/mock"

	onchain "github.com/BoltzExchange/boltz-client/onchain"
)

// MockLightningNode is an autogenerated mock type for the LightningNode type
type MockLightningNode struct {
	mock.Mock
}

type MockLightningNode_Expecter struct {
	mock *mock.Mock
}

func (_m *MockLightningNode) EXPECT() *MockLightningNode_Expecter {
	return &MockLightningNode_Expecter{mock: &_m.Mock}
}

// CheckInvoicePaid provides a mock function with given fields: paymentHash
func (_m *MockLightningNode) CheckInvoicePaid(paymentHash []byte) (bool, error) {
	ret := _m.Called(paymentHash)

	if len(ret) == 0 {
		panic("no return value specified for CheckInvoicePaid")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func([]byte) (bool, error)); ok {
		return rf(paymentHash)
	}
	if rf, ok := ret.Get(0).(func([]byte) bool); ok {
		r0 = rf(paymentHash)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = rf(paymentHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLightningNode_CheckInvoicePaid_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckInvoicePaid'
type MockLightningNode_CheckInvoicePaid_Call struct {
	*mock.Call
}

// CheckInvoicePaid is a helper method to define mock.On call
//   - paymentHash []byte
func (_e *MockLightningNode_Expecter) CheckInvoicePaid(paymentHash interface{}) *MockLightningNode_CheckInvoicePaid_Call {
	return &MockLightningNode_CheckInvoicePaid_Call{Call: _e.mock.On("CheckInvoicePaid", paymentHash)}
}

func (_c *MockLightningNode_CheckInvoicePaid_Call) Run(run func(paymentHash []byte)) *MockLightningNode_CheckInvoicePaid_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]byte))
	})
	return _c
}

func (_c *MockLightningNode_CheckInvoicePaid_Call) Return(_a0 bool, _a1 error) *MockLightningNode_CheckInvoicePaid_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLightningNode_CheckInvoicePaid_Call) RunAndReturn(run func([]byte) (bool, error)) *MockLightningNode_CheckInvoicePaid_Call {
	_c.Call.Return(run)
	return _c
}

// Connect provides a mock function with given fields:
func (_m *MockLightningNode) Connect() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Connect")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockLightningNode_Connect_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Connect'
type MockLightningNode_Connect_Call struct {
	*mock.Call
}

// Connect is a helper method to define mock.On call
func (_e *MockLightningNode_Expecter) Connect() *MockLightningNode_Connect_Call {
	return &MockLightningNode_Connect_Call{Call: _e.mock.On("Connect")}
}

func (_c *MockLightningNode_Connect_Call) Run(run func()) *MockLightningNode_Connect_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockLightningNode_Connect_Call) Return(_a0 error) *MockLightningNode_Connect_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLightningNode_Connect_Call) RunAndReturn(run func() error) *MockLightningNode_Connect_Call {
	_c.Call.Return(run)
	return _c
}

// ConnectPeer provides a mock function with given fields: uri
func (_m *MockLightningNode) ConnectPeer(uri string) error {
	ret := _m.Called(uri)

	if len(ret) == 0 {
		panic("no return value specified for ConnectPeer")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(uri)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockLightningNode_ConnectPeer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConnectPeer'
type MockLightningNode_ConnectPeer_Call struct {
	*mock.Call
}

// ConnectPeer is a helper method to define mock.On call
//   - uri string
func (_e *MockLightningNode_Expecter) ConnectPeer(uri interface{}) *MockLightningNode_ConnectPeer_Call {
	return &MockLightningNode_ConnectPeer_Call{Call: _e.mock.On("ConnectPeer", uri)}
}

func (_c *MockLightningNode_ConnectPeer_Call) Run(run func(uri string)) *MockLightningNode_ConnectPeer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockLightningNode_ConnectPeer_Call) Return(_a0 error) *MockLightningNode_ConnectPeer_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLightningNode_ConnectPeer_Call) RunAndReturn(run func(string) error) *MockLightningNode_ConnectPeer_Call {
	_c.Call.Return(run)
	return _c
}

// CreateInvoice provides a mock function with given fields: value, preimage, expiry, memo
func (_m *MockLightningNode) CreateInvoice(value uint64, preimage []byte, expiry int64, memo string) (*lightning.AddInvoiceResponse, error) {
	ret := _m.Called(value, preimage, expiry, memo)

	if len(ret) == 0 {
		panic("no return value specified for CreateInvoice")
	}

	var r0 *lightning.AddInvoiceResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(uint64, []byte, int64, string) (*lightning.AddInvoiceResponse, error)); ok {
		return rf(value, preimage, expiry, memo)
	}
	if rf, ok := ret.Get(0).(func(uint64, []byte, int64, string) *lightning.AddInvoiceResponse); ok {
		r0 = rf(value, preimage, expiry, memo)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lightning.AddInvoiceResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(uint64, []byte, int64, string) error); ok {
		r1 = rf(value, preimage, expiry, memo)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLightningNode_CreateInvoice_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateInvoice'
type MockLightningNode_CreateInvoice_Call struct {
	*mock.Call
}

// CreateInvoice is a helper method to define mock.On call
//   - value uint64
//   - preimage []byte
//   - expiry int64
//   - memo string
func (_e *MockLightningNode_Expecter) CreateInvoice(value interface{}, preimage interface{}, expiry interface{}, memo interface{}) *MockLightningNode_CreateInvoice_Call {
	return &MockLightningNode_CreateInvoice_Call{Call: _e.mock.On("CreateInvoice", value, preimage, expiry, memo)}
}

func (_c *MockLightningNode_CreateInvoice_Call) Run(run func(value uint64, preimage []byte, expiry int64, memo string)) *MockLightningNode_CreateInvoice_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint64), args[1].([]byte), args[2].(int64), args[3].(string))
	})
	return _c
}

func (_c *MockLightningNode_CreateInvoice_Call) Return(_a0 *lightning.AddInvoiceResponse, _a1 error) *MockLightningNode_CreateInvoice_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLightningNode_CreateInvoice_Call) RunAndReturn(run func(uint64, []byte, int64, string) (*lightning.AddInvoiceResponse, error)) *MockLightningNode_CreateInvoice_Call {
	_c.Call.Return(run)
	return _c
}

// Disconnect provides a mock function with given fields:
func (_m *MockLightningNode) Disconnect() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Disconnect")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockLightningNode_Disconnect_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Disconnect'
type MockLightningNode_Disconnect_Call struct {
	*mock.Call
}

// Disconnect is a helper method to define mock.On call
func (_e *MockLightningNode_Expecter) Disconnect() *MockLightningNode_Disconnect_Call {
	return &MockLightningNode_Disconnect_Call{Call: _e.mock.On("Disconnect")}
}

func (_c *MockLightningNode_Disconnect_Call) Run(run func()) *MockLightningNode_Disconnect_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockLightningNode_Disconnect_Call) Return(_a0 error) *MockLightningNode_Disconnect_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLightningNode_Disconnect_Call) RunAndReturn(run func() error) *MockLightningNode_Disconnect_Call {
	_c.Call.Return(run)
	return _c
}

// GetBalance provides a mock function with given fields:
func (_m *MockLightningNode) GetBalance() (*onchain.Balance, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetBalance")
	}

	var r0 *onchain.Balance
	var r1 error
	if rf, ok := ret.Get(0).(func() (*onchain.Balance, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() *onchain.Balance); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*onchain.Balance)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLightningNode_GetBalance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBalance'
type MockLightningNode_GetBalance_Call struct {
	*mock.Call
}

// GetBalance is a helper method to define mock.On call
func (_e *MockLightningNode_Expecter) GetBalance() *MockLightningNode_GetBalance_Call {
	return &MockLightningNode_GetBalance_Call{Call: _e.mock.On("GetBalance")}
}

func (_c *MockLightningNode_GetBalance_Call) Run(run func()) *MockLightningNode_GetBalance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockLightningNode_GetBalance_Call) Return(_a0 *onchain.Balance, _a1 error) *MockLightningNode_GetBalance_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLightningNode_GetBalance_Call) RunAndReturn(run func() (*onchain.Balance, error)) *MockLightningNode_GetBalance_Call {
	_c.Call.Return(run)
	return _c
}

// GetInfo provides a mock function with given fields:
func (_m *MockLightningNode) GetInfo() (*lightning.LightningInfo, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetInfo")
	}

	var r0 *lightning.LightningInfo
	var r1 error
	if rf, ok := ret.Get(0).(func() (*lightning.LightningInfo, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() *lightning.LightningInfo); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lightning.LightningInfo)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLightningNode_GetInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetInfo'
type MockLightningNode_GetInfo_Call struct {
	*mock.Call
}

// GetInfo is a helper method to define mock.On call
func (_e *MockLightningNode_Expecter) GetInfo() *MockLightningNode_GetInfo_Call {
	return &MockLightningNode_GetInfo_Call{Call: _e.mock.On("GetInfo")}
}

func (_c *MockLightningNode_GetInfo_Call) Run(run func()) *MockLightningNode_GetInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockLightningNode_GetInfo_Call) Return(_a0 *lightning.LightningInfo, _a1 error) *MockLightningNode_GetInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLightningNode_GetInfo_Call) RunAndReturn(run func() (*lightning.LightningInfo, error)) *MockLightningNode_GetInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetWalletInfo provides a mock function with given fields:
func (_m *MockLightningNode) GetWalletInfo() onchain.WalletInfo {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetWalletInfo")
	}

	var r0 onchain.WalletInfo
	if rf, ok := ret.Get(0).(func() onchain.WalletInfo); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(onchain.WalletInfo)
	}

	return r0
}

// MockLightningNode_GetWalletInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWalletInfo'
type MockLightningNode_GetWalletInfo_Call struct {
	*mock.Call
}

// GetWalletInfo is a helper method to define mock.On call
func (_e *MockLightningNode_Expecter) GetWalletInfo() *MockLightningNode_GetWalletInfo_Call {
	return &MockLightningNode_GetWalletInfo_Call{Call: _e.mock.On("GetWalletInfo")}
}

func (_c *MockLightningNode_GetWalletInfo_Call) Run(run func()) *MockLightningNode_GetWalletInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockLightningNode_GetWalletInfo_Call) Return(_a0 onchain.WalletInfo) *MockLightningNode_GetWalletInfo_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLightningNode_GetWalletInfo_Call) RunAndReturn(run func() onchain.WalletInfo) *MockLightningNode_GetWalletInfo_Call {
	_c.Call.Return(run)
	return _c
}

// ListChannels provides a mock function with given fields:
func (_m *MockLightningNode) ListChannels() ([]*lightning.LightningChannel, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ListChannels")
	}

	var r0 []*lightning.LightningChannel
	var r1 error
	if rf, ok := ret.Get(0).(func() ([]*lightning.LightningChannel, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []*lightning.LightningChannel); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*lightning.LightningChannel)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLightningNode_ListChannels_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListChannels'
type MockLightningNode_ListChannels_Call struct {
	*mock.Call
}

// ListChannels is a helper method to define mock.On call
func (_e *MockLightningNode_Expecter) ListChannels() *MockLightningNode_ListChannels_Call {
	return &MockLightningNode_ListChannels_Call{Call: _e.mock.On("ListChannels")}
}

func (_c *MockLightningNode_ListChannels_Call) Run(run func()) *MockLightningNode_ListChannels_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockLightningNode_ListChannels_Call) Return(_a0 []*lightning.LightningChannel, _a1 error) *MockLightningNode_ListChannels_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLightningNode_ListChannels_Call) RunAndReturn(run func() ([]*lightning.LightningChannel, error)) *MockLightningNode_ListChannels_Call {
	_c.Call.Return(run)
	return _c
}

// Name provides a mock function with given fields:
func (_m *MockLightningNode) Name() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Name")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// MockLightningNode_Name_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Name'
type MockLightningNode_Name_Call struct {
	*mock.Call
}

// Name is a helper method to define mock.On call
func (_e *MockLightningNode_Expecter) Name() *MockLightningNode_Name_Call {
	return &MockLightningNode_Name_Call{Call: _e.mock.On("Name")}
}

func (_c *MockLightningNode_Name_Call) Run(run func()) *MockLightningNode_Name_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockLightningNode_Name_Call) Return(_a0 string) *MockLightningNode_Name_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLightningNode_Name_Call) RunAndReturn(run func() string) *MockLightningNode_Name_Call {
	_c.Call.Return(run)
	return _c
}

// NewAddress provides a mock function with given fields:
func (_m *MockLightningNode) NewAddress() (string, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for NewAddress")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func() (string, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLightningNode_NewAddress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewAddress'
type MockLightningNode_NewAddress_Call struct {
	*mock.Call
}

// NewAddress is a helper method to define mock.On call
func (_e *MockLightningNode_Expecter) NewAddress() *MockLightningNode_NewAddress_Call {
	return &MockLightningNode_NewAddress_Call{Call: _e.mock.On("NewAddress")}
}

func (_c *MockLightningNode_NewAddress_Call) Run(run func()) *MockLightningNode_NewAddress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockLightningNode_NewAddress_Call) Return(_a0 string, _a1 error) *MockLightningNode_NewAddress_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLightningNode_NewAddress_Call) RunAndReturn(run func() (string, error)) *MockLightningNode_NewAddress_Call {
	_c.Call.Return(run)
	return _c
}

// PayInvoice provides a mock function with given fields: ctx, invoice, feeLimit, timeoutSeconds, channelIds
func (_m *MockLightningNode) PayInvoice(ctx context.Context, invoice string, feeLimit uint, timeoutSeconds uint, channelIds []lightning.ChanId) (*lightning.PayInvoiceResponse, error) {
	ret := _m.Called(ctx, invoice, feeLimit, timeoutSeconds, channelIds)

	if len(ret) == 0 {
		panic("no return value specified for PayInvoice")
	}

	var r0 *lightning.PayInvoiceResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, uint, uint, []lightning.ChanId) (*lightning.PayInvoiceResponse, error)); ok {
		return rf(ctx, invoice, feeLimit, timeoutSeconds, channelIds)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, uint, uint, []lightning.ChanId) *lightning.PayInvoiceResponse); ok {
		r0 = rf(ctx, invoice, feeLimit, timeoutSeconds, channelIds)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lightning.PayInvoiceResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, uint, uint, []lightning.ChanId) error); ok {
		r1 = rf(ctx, invoice, feeLimit, timeoutSeconds, channelIds)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLightningNode_PayInvoice_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PayInvoice'
type MockLightningNode_PayInvoice_Call struct {
	*mock.Call
}

// PayInvoice is a helper method to define mock.On call
//   - ctx context.Context
//   - invoice string
//   - feeLimit uint
//   - timeoutSeconds uint
//   - channelIds []lightning.ChanId
func (_e *MockLightningNode_Expecter) PayInvoice(ctx interface{}, invoice interface{}, feeLimit interface{}, timeoutSeconds interface{}, channelIds interface{}) *MockLightningNode_PayInvoice_Call {
	return &MockLightningNode_PayInvoice_Call{Call: _e.mock.On("PayInvoice", ctx, invoice, feeLimit, timeoutSeconds, channelIds)}
}

func (_c *MockLightningNode_PayInvoice_Call) Run(run func(ctx context.Context, invoice string, feeLimit uint, timeoutSeconds uint, channelIds []lightning.ChanId)) *MockLightningNode_PayInvoice_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(uint), args[3].(uint), args[4].([]lightning.ChanId))
	})
	return _c
}

func (_c *MockLightningNode_PayInvoice_Call) Return(_a0 *lightning.PayInvoiceResponse, _a1 error) *MockLightningNode_PayInvoice_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLightningNode_PayInvoice_Call) RunAndReturn(run func(context.Context, string, uint, uint, []lightning.ChanId) (*lightning.PayInvoiceResponse, error)) *MockLightningNode_PayInvoice_Call {
	_c.Call.Return(run)
	return _c
}

// PaymentStatus provides a mock function with given fields: paymentHash
func (_m *MockLightningNode) PaymentStatus(paymentHash []byte) (*lightning.PaymentStatus, error) {
	ret := _m.Called(paymentHash)

	if len(ret) == 0 {
		panic("no return value specified for PaymentStatus")
	}

	var r0 *lightning.PaymentStatus
	var r1 error
	if rf, ok := ret.Get(0).(func([]byte) (*lightning.PaymentStatus, error)); ok {
		return rf(paymentHash)
	}
	if rf, ok := ret.Get(0).(func([]byte) *lightning.PaymentStatus); ok {
		r0 = rf(paymentHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lightning.PaymentStatus)
		}
	}

	if rf, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = rf(paymentHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLightningNode_PaymentStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PaymentStatus'
type MockLightningNode_PaymentStatus_Call struct {
	*mock.Call
}

// PaymentStatus is a helper method to define mock.On call
//   - paymentHash []byte
func (_e *MockLightningNode_Expecter) PaymentStatus(paymentHash interface{}) *MockLightningNode_PaymentStatus_Call {
	return &MockLightningNode_PaymentStatus_Call{Call: _e.mock.On("PaymentStatus", paymentHash)}
}

func (_c *MockLightningNode_PaymentStatus_Call) Run(run func(paymentHash []byte)) *MockLightningNode_PaymentStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]byte))
	})
	return _c
}

func (_c *MockLightningNode_PaymentStatus_Call) Return(_a0 *lightning.PaymentStatus, _a1 error) *MockLightningNode_PaymentStatus_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLightningNode_PaymentStatus_Call) RunAndReturn(run func([]byte) (*lightning.PaymentStatus, error)) *MockLightningNode_PaymentStatus_Call {
	_c.Call.Return(run)
	return _c
}

// Ready provides a mock function with given fields:
func (_m *MockLightningNode) Ready() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Ready")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// MockLightningNode_Ready_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Ready'
type MockLightningNode_Ready_Call struct {
	*mock.Call
}

// Ready is a helper method to define mock.On call
func (_e *MockLightningNode_Expecter) Ready() *MockLightningNode_Ready_Call {
	return &MockLightningNode_Ready_Call{Call: _e.mock.On("Ready")}
}

func (_c *MockLightningNode_Ready_Call) Run(run func()) *MockLightningNode_Ready_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockLightningNode_Ready_Call) Return(_a0 bool) *MockLightningNode_Ready_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLightningNode_Ready_Call) RunAndReturn(run func() bool) *MockLightningNode_Ready_Call {
	_c.Call.Return(run)
	return _c
}

// SendToAddress provides a mock function with given fields: address, amount, satPerVbyte
func (_m *MockLightningNode) SendToAddress(address string, amount uint64, satPerVbyte float64) (string, error) {
	ret := _m.Called(address, amount, satPerVbyte)

	if len(ret) == 0 {
		panic("no return value specified for SendToAddress")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, uint64, float64) (string, error)); ok {
		return rf(address, amount, satPerVbyte)
	}
	if rf, ok := ret.Get(0).(func(string, uint64, float64) string); ok {
		r0 = rf(address, amount, satPerVbyte)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, uint64, float64) error); ok {
		r1 = rf(address, amount, satPerVbyte)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLightningNode_SendToAddress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendToAddress'
type MockLightningNode_SendToAddress_Call struct {
	*mock.Call
}

// SendToAddress is a helper method to define mock.On call
//   - address string
//   - amount uint64
//   - satPerVbyte float64
func (_e *MockLightningNode_Expecter) SendToAddress(address interface{}, amount interface{}, satPerVbyte interface{}) *MockLightningNode_SendToAddress_Call {
	return &MockLightningNode_SendToAddress_Call{Call: _e.mock.On("SendToAddress", address, amount, satPerVbyte)}
}

func (_c *MockLightningNode_SendToAddress_Call) Run(run func(address string, amount uint64, satPerVbyte float64)) *MockLightningNode_SendToAddress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(uint64), args[2].(float64))
	})
	return _c
}

func (_c *MockLightningNode_SendToAddress_Call) Return(_a0 string, _a1 error) *MockLightningNode_SendToAddress_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLightningNode_SendToAddress_Call) RunAndReturn(run func(string, uint64, float64) (string, error)) *MockLightningNode_SendToAddress_Call {
	_c.Call.Return(run)
	return _c
}

// SetupWallet provides a mock function with given fields: info
func (_m *MockLightningNode) SetupWallet(info onchain.WalletInfo) {
	_m.Called(info)
}

// MockLightningNode_SetupWallet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetupWallet'
type MockLightningNode_SetupWallet_Call struct {
	*mock.Call
}

// SetupWallet is a helper method to define mock.On call
//   - info onchain.WalletInfo
func (_e *MockLightningNode_Expecter) SetupWallet(info interface{}) *MockLightningNode_SetupWallet_Call {
	return &MockLightningNode_SetupWallet_Call{Call: _e.mock.On("SetupWallet", info)}
}

func (_c *MockLightningNode_SetupWallet_Call) Run(run func(info onchain.WalletInfo)) *MockLightningNode_SetupWallet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(onchain.WalletInfo))
	})
	return _c
}

func (_c *MockLightningNode_SetupWallet_Call) Return() *MockLightningNode_SetupWallet_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockLightningNode_SetupWallet_Call) RunAndReturn(run func(onchain.WalletInfo)) *MockLightningNode_SetupWallet_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockLightningNode creates a new instance of MockLightningNode. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockLightningNode(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockLightningNode {
	mock := &MockLightningNode{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
